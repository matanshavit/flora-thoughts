---
date: 2025-10-17 18:14:53 EDT
researcher: matanshavit
git_commit: 1ed9f0aeafff25ea27a618b90b9bf0e1d202a4a3
branch: eng-1126
repository: eng-1126
topic: "ImageKit video pregeneration and optimization delay"
tags: [research, codebase, imagekit, video, optimization, pregeneration, transformation]
status: complete
last_updated: 2025-10-17
last_updated_by: matanshavit
---

# Research: ImageKit Video Pregeneration and Optimization Delay

**Date**: 2025-10-17 18:14:53 EDT
**Researcher**: matanshavit
**Git Commit**: 1ed9f0aeafff25ea27a618b90b9bf0e1d202a4a3
**Branch**: eng-1126
**Repository**: eng-1126

## Research Question

The links take a few extra seconds to load because ImageKit has to generate the modified video. If I refresh the page, the video previews load very quickly. Is there a built-in way in ImageKit to ensure the videos from the links that are to be loaded get generated on page load?

## Summary

ImageKit **does support video pre-generation** through two primary methods:
1. **Eager generation (post-transformations)** - Applied at upload time via the Upload API to pre-generate up to 5 transformation variants
2. **Manual warming** - Making requests to transformation URLs before users access them to trigger generation and caching

The current Flora implementation applies ImageKit transformations at load time via URL parameters, which causes the initial delay. Once generated, transformations are cached forever by ImageKit. The codebase has existing preloading patterns that could be adapted to warm video transformations before user interaction.

## Detailed Findings

### Current ImageKit Video Optimization Implementation

The video optimization system was recently implemented in the last commit (1ed9f0aea) based on the plan in `thoughts/shared/plans/2025-10-17-ENG-1126-imagekit-video-optimizations.md`.

#### URL Transformation (`src/lib/videos/video-texture-loader.ts:107-152`)

The system transforms ImageKit video URLs using quality presets:

- **Detection**: Only processes URLs starting with `https://ik.imagekit.io/`
- **Skip logic**: Avoids double-processing by checking for existing `?tr=` or `/tr:` parameters
- **Quality presets** (lines 121-140):
  - Low: WebM, 480p, quality 40, 10s duration limit
  - Medium: WebM, 720p, quality 50, 10s duration limit
  - High: WebM, 1080p, quality 60, 10s duration limit
- **Transformation format**: Query parameter style `?tr=f-webm,h-720,c-at_max,q-50,du-10`

#### Loading Flow (`src/lib/videos/video-texture-loader.ts:392-441`)

The `loadVideoTexture()` method:
1. Applies URL optimization based on quality setting (default "medium")
2. Checks cache for existing texture/loading promise
3. Attempts worker-based loading with 15-second timeout
4. Falls back to main thread if worker fails
5. Creates THREE.VideoTexture from loaded video

### ImageKit Pre-generation Capabilities

Research from ImageKit documentation reveals two primary methods for avoiding transformation delay:

#### Method 1: Post-Transformations at Upload Time

**Documentation**: [Pre & Post-upload transformations](https://imagekit.io/docs/dam/pre-and-post-transformation-on-upload)

Post-transformations allow eager generation of transformations after upload:
- Supports up to **5 post-transformations** per asset
- Always **asynchronous** for videos
- Supported transformation types:
  - `transformation` - General video transformations
  - `abs` - Adaptive Bitrate Streaming
  - `thumbnail` - Extract thumbnail from video

Example Upload API request with post-transformations:
```json
{
  "transformation": {
    "post": [
      {
        "type": "transformation",
        "value": "f-webm,h-720,c-at_max,q-50,du-10"
      },
      {
        "type": "transformation",
        "value": "f-webm,h-480,c-at_max,q-40,du-10"
      }
    ]
  }
}
```

#### Method 2: Manual URL Warming

**Documentation**: [Video Transformation](https://imagekit.io/docs/video-transformation)

For existing videos, transformations can be pre-generated by:
1. Making a GET or HEAD request to the transformed URL
2. ImageKit starts processing and caches the result forever
3. Subsequent requests serve the cached version instantly

First request behavior:
- ImageKit checks its cache
- If not cached, starts processing and either:
  - Returns **302 redirect** to original (immediate response)
  - **Waits up to 15 seconds** for transformation to complete (configurable in dashboard)
- Once processed, transformations are **cached forever**

### Existing Preloading Patterns in Codebase

The codebase has several preloading patterns that could be adapted for video warming:

#### Pattern 1: Worker File Preloading (`src/lib/videos/video-texture-loader.ts:157-175`)

Uses HEAD request with `cache: "force-cache"` to preload worker script:
```typescript
await fetch("/workers/video-processor.worker.js", {
  method: "HEAD",
  cache: "force-cache",
});
```

#### Pattern 2: ImageKit Transformation Warming (`src/lib/schema/map-before-request.ts:1748-1760`)

Already implements pre-warming for some transformations:
```typescript
const transform = `h-${bestH},w-${bestW},cm-extract`;
const sep = newParams.video_url.includes("?") ? "&" : "?";
newParams.video_url = `${newParams.video_url}${sep}tr=${transform}`;

try {
  await fetch(newParams.video_url);
} catch (e) {
  // Ignore errors, just trigger transformation
}
```

#### Pattern 3: Polling for ImageKit Readiness (`src/lib/schema/map-before-request.ts:1516-1560`)

Implements retry logic with HEAD requests to wait for transformations:
```typescript
for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
  const res = await fetch(newParams.video_url, {
    method: "HEAD",
    cache: "no-store",
    redirect: "manual", // Don't follow redirects - 302 means still processing
  });

  if (res.ok && res.headers.get("content-type")?.startsWith("video/")) {
    success = true;
    break;
  }

  await new Promise(resolve => setTimeout(resolve, 2500));
}
```

#### Pattern 4: R3F Asset Preloading (`src/lib/r3f/preloader.tsx:176-191`)

Uses requestIdleCallback for non-blocking preload:
```typescript
if ("requestIdleCallback" in window) {
  requestIdleCallback(() => preloadR3FAssets());
} else {
  setTimeout(() => preloadR3FAssets(), 1000);
}
```

#### Pattern 5: Lazy Media Queue (`src/components/r3f/lazy-media-loader.tsx:28-206`)

Implements concurrent loading with queue management:
- MAX_CONCURRENT_LOADS = 3
- Reference counting for cache management
- Automatic cleanup when cache exceeds 50 items

### Implementation Recommendations

Based on the research, here are approaches to pre-generate video transformations:

#### Approach 1: Warm on Component Mount (Immediate Solution)

Add warming logic to `VideoMaterial` component or `VideoTextureCoordinator`:

```typescript
// In video-texture-loader.ts, add warming method:
async warmVideoTransformations(videoUrl: string, qualities: string[] = ["low", "medium", "high"]) {
  if (!videoUrl.startsWith("https://ik.imagekit.io/")) return;

  const warmingPromises = qualities.map(quality => {
    const optimizedUrl = this.getOptimizedVideoUrl(videoUrl, quality);
    return fetch(optimizedUrl, {
      method: "HEAD",
      cache: "no-store" // Ensure we hit ImageKit, not browser cache
    }).catch(() => {}); // Ignore errors
  });

  await Promise.all(warmingPromises);
}
```

#### Approach 2: Background Prewarming During Idle Time

Leverage requestIdleCallback pattern from R3F preloader:

```typescript
// Warm all video transformations when browser is idle
function warmVideoTransformations(videoUrls: string[]) {
  if ("requestIdleCallback" in window) {
    requestIdleCallback(() => {
      videoUrls.forEach(url => {
        videoCoordinator.warmVideoTransformations(url);
      });
    }, { timeout: 2000 });
  }
}
```

#### Approach 3: Upload-Time Pre-generation (Long-term Solution)

Modify upload flow to include post-transformations:

```typescript
// When uploading to ImageKit, include post-transformations
const uploadParams = {
  file: videoFile,
  transformation: {
    post: [
      { type: "transformation", value: "f-webm,h-480,c-at_max,q-40,du-10" },  // low
      { type: "transformation", value: "f-webm,h-720,c-at_max,q-50,du-10" },  // medium
      { type: "transformation", value: "f-webm,h-1080,c-at_max,q-60,du-10" }, // high
    ]
  }
};
```

### Architecture Documentation

#### Video Loading Pipeline

1. **Component Level** (`src/components/r3f/blocks/video/video-material.tsx`)
   - Receives video URL and quality setting
   - Calls `videoCoordinator.loadVideoTexture()`

2. **Optimization Layer** (`src/lib/videos/video-texture-loader.ts:107-152`)
   - Transforms ImageKit URLs based on quality presets
   - Adds format, resolution, quality, and duration constraints

3. **Loading Strategy** (`src/lib/videos/video-texture-loader.ts:443-564`)
   - Attempts Web Worker loading with 15s timeout
   - Falls back to main thread on failure
   - Uses requestIdleCallback when available

4. **Caching Layers**
   - Texture cache by blockId (lines 85, 411-413)
   - Loading promise deduplication (lines 86, 407-409)
   - Worker-side blob cache (worker.js:21)
   - ImageKit CDN cache (permanent after first generation)

#### Performance Monitoring

The system tracks video load performance in non-production:
- `videoPerformanceMonitor.startVideoLoad()` marks start time
- Monitors for slow loads over 2000ms
- Records optimization application

## Historical Context (from thoughts/)

From `thoughts/shared/plans/2025-10-17-ENG-1126-imagekit-video-optimizations.md`:
- Implementation was designed as a "targeted optimization that leverages existing ImageKit infrastructure"
- Chose query parameter format (`?tr=`) over path-based for simplicity
- 15-second timeout was kept as-is (not modified)
- WebM format reduces file size by ~30% vs MP4
- 720p reduces size by ~60-75% vs 1080p
- First transformation request may be slower (ImageKit processing time)
- Subsequent requests use ImageKit's CDN cache

## Code References

- `src/lib/videos/video-texture-loader.ts:107-152` - getOptimizedVideoUrl() implementation
- `src/lib/videos/video-texture-loader.ts:392-441` - loadVideoTexture() main entry point
- `src/components/r3f/blocks/video/video-material.tsx:109-116` - Video material loading
- `src/lib/schema/map-before-request.ts:1748-1760` - Existing transformation warming pattern
- `src/lib/r3f/preloader.tsx:176-191` - requestIdleCallback preloading pattern
- `public/workers/video-processor.worker.js:77-127` - Worker video processing

## Related Research

- `thoughts/shared/research/2025-10-17-ENG-1126-video-optimization-web-workers.md` - Original research for video optimization
- `thoughts/shared/plans/2025-10-17-ENG-1126-imagekit-video-optimizations.md` - Implementation plan

## Open Questions

1. Should warming be implemented at component level or globally during app initialization?
2. Would upload-time post-transformations work with the current upload flow?
3. Should we implement polling to wait for transformations to complete before showing videos?
4. Is the 15-second dashboard wait time configuration optimal for Flora's use case?